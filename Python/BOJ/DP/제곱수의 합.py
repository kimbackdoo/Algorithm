# n이 1, 2, 3, 4, 5, 6, 7, 8, ... 일 때, 최소개수는 각각 1, 2, 3, 1, 2, 3, 2, ... 가 됨
# 즉, n이 제곱수라면 1, 제곱수가 아니라면 f(n) = min(f(1) + f(n-1), f(4) + f(n-4), f(9) + f(n-9), ...)가 된다

# n = int(input())

# dp = [10001] * (n+1) # n의 최대값이 10000이므로 최대개수는 10000이 되므로 절대 될 수 없는 10001로 dp 테이블 초기화
# dp[1] = 1 # 1은 1
# for i in range(2, n+1):
#   if i**0.5 == int(i**0.5): # 만약 i가 제곱수라면 dp[i] = 1
#     dp[i] = 1
#   else: # i가 제곱수가 아니라면
#     for j in range(1, int(i**0.5) + 1): # 위 점화식을 적용하기 위해 1부터 i의 제곱근 + 1까지 반복해서 최소값을 dp[i]에 저장
#       dp[i] = min(dp[i], dp[j**2] + dp[i - j**2])

# print(dp[n])

# for문에서 반복적으로 min 함수를 호출하는 것보다 if문을 사용하는 것이 속도가 빠름
# f(1), f(4), f(9)는 제곱수 이므로 무조건 1이므로 위 점화식은
# f(n) = min(f(n-1) + 1, f(n-4) + 1, f(n-9) + 1, ...)가 됨

n = int(input())

dp = [10001] * (n+1)
dp[1] = 1
for i in range(2, n+1):
  if i**0.5 == int(i**0.5):
    dp[i] = 1
  else:
    for j in range(1, int(i**0.5) + 1):
      if dp[i] > dp[i - j**2] + 1: # min 함수 대신 if문을 사용하여 속도 개선, 수정한 점화식 적용
        dp[i] = dp[i - j**2] + 1
        
print(dp[n])
