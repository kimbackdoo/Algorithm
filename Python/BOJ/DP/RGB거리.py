# 처음에는 리스트의 pop연산과 모든 경우의 수를 통해 구하려고 했으나 시간초과 및 틀림
# 모든 집을 칠하는 비용의 최솟값을 구해야하고, i번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 함
# 즉, 점화식을 통해 다이나믹 프로그래밍 알고리즘 적용
# 모든 집은 R, G, B 중 하나만 색칠해야 하고, 전 집의 색깔은 사용하면 안됨
# 따라서 점화식은 f[i][j] = f[i][j] + min(f[i-1][k], f[i-1][l]) (j, k, l은 모두 달라야함)
# 예를 들어, f[i][0] = f[i][0] + min(f[i-1][1], f[i-1][2])

import sys
input = sys.stdin.readline

n = int(input())
rgb = [list(map(int, input().split())) for _ in range(n)]

for i in range(1, n): # 1번 집부터 n번 집까지 반복
  rgb[i][0] += min(rgb[i-1][1], rgb[i-1][2]) # i번 집을 0으로 색칠할 경우, 그 전 1, 2의 최소값과 현재 0의 값을 더하면 됨
  rgb[i][1] += min(rgb[i-1][0], rgb[i-1][2]) # i번 집을 1으로 색칠할 경우, 그 전 0, 2의 최소값과 현재 1의 값을 더하면 됨
  rgb[i][2] += min(rgb[i-1][0], rgb[i-1][1]) # i번 집을 2으로 색칠할 경우, 그 전 0, 1의 최소값과 현재 2의 값을 더하면 됨

print(min(rgb[n-1])) # 계산된 rgb[n-1]의 값 중에서 최소 값이 최소 비용이 됨
