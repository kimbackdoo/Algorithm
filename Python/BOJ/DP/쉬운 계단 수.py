# n이 1부터 계단 수의 개수를 구하면 아래와 같다.
# 최고 자리 수       1 2 3 4 5 6 7 8 9
#           n : 1 => 1 1 1 1 1 1 1 1 1 # 즉, n이 1일 때, 최고 자리 수가 1 ~ 9일 경우 계단 수는 모두 1개
#           n : 2 => 2 2 2 2 2 2 2 2 1 # 즉, n이 2일 때, 최고 자리 수가 1 ~ 8일 경우 계단 수는 2개, 9일 경우 계단 수는 1개
#           n : 3 => 3 4 4 4 4 4 4 3 2 # 즉, n이 3일 때, 최고 자리 수가 1일 경우 계단 수는 3개, 2 ~ 7일 경우 계단 수는 4개, 8일 경우 계단 수는 3개, 9일 경우 계단 수는 2개
# 여기서 규칙을 찾아보면 f[3][1] = f[1][1] + f[2][2], f[3][i] = f[3][i-1] + f[3][i+1] (2 <= i <= 8), f[3][9] = f[3][8] 이 되므로
# f[n][1] = f[n-2][1] + f[n-1][2], f[n][i] = f[n-1][i-1] + f[n-1][i+1] (2 <= i <= 8), f[n][9] = f[n-1][8] 점화식을 세울 수 있음

from collections import defaultdict

n = int(input())

dp = defaultdict(list) # 2차원 리스트를 생성하지 않고 defaultdict을 사용하여 n이 1부터 n까지 value가 리스트인 dict 생성
dp[1] = [1] * 9 # n이 1일 때 리스트
dp[2] = [2] * 8 + [1] # n이 2일 때 리스트
for i in range(3, n+1): # 3부터 n까지 반복
  # 위 점화식 적용, 리스트의 인덱스는 0부터 시작하므로 최고 자리 수가 1인 경우의 개수는 0번째 요소에 저장
  dp[i].append((dp[i-2][0] + dp[i-1][1])) # 최고 자리 수가 1일 경우에는 n-2번째 요소의 첫번째 요소와 n-1번째 요소의 두번째 요소의 합
  for j in range(1, 8): # 최고 자리 수가 2부터 8일 경우
     dp[i].append((dp[i-1][j-1] + dp[i-1][j+1])) # dp[i-1][j-1] + dp[i-1][j+1] 저장

  dp[i].append(dp[i-1][7]) # 최고 자리 수가 9일 경우 n-1번째 요소의 최고 자리 수가 8인 경우의 수 즉, dp[i-1][7]

print(sum(dp[n]) % 1000000000)
