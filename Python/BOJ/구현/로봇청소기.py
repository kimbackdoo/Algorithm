# 문제의 조건을 그대로 구현하면 됨
# 1. 현재의 위치를 청소한다. -> 청소한 위치를 2로 저장 이유는 후진할 때 청소한 위치로 후진할 수 있기 때문 즉, 벽이 아니면 청소를 했든 안했든 후진 가능
# 2.a. 왼쪽 방향으로 회전하고 전진 -> 처음 방향이 d로 입력받고 방향은 북(1), 동(2), 남(3), 서(4)이다.
# 즉, 청소기가 움직일 수 있는 방향이 상하좌우이고, d%4 연산을 하여 다음 위치로 이동할 수 있음
# 2.b. 방향만 회전
# 2.c. 후진을 할 때 이미 청소한 위치로도 후진할 수 있다.
# 2.d. 후진을 할 수 없는 경우는 사방이 청소가 되어 있거나 벽이면서, 후진을 할 위치도 벽인 경우

n, m = map(int, input().split())
r, c, d = map(int, input().split())

places = []
for _ in range(n):
  places.append(list(map(int, input().split())))

move = [(-1, 0), (0, 1), (1, 0), (0, -1)] # 청소기가 움직일 수 있는 위치 값
places[r][c] = 2 # 처음 위치 청소 표시
turn_cnt, cnt = 0, 1 # turn_cnt: 네 방향을 체크할 변수, cnt: 칸 개수를 count할 변수
while True:
  d -= 1 # 왼쪽 방향으로 회전
  # 네 방향이므로 %4 연산을 하여 어느방향으로 이동할지 결정
  # 예를 들어, d=0 이면 d%4=0 즉, 북, d=-1 이면 d%4=3 즉, 서, ...
  nr, nc = r + move[d % 4][0], c + move[d % 4][1] # 회전 이후 앞으로 전진
  if places[nr][nc] == 0: # 회전 이후 전진할 위치가 청소가 안되어 있다면
    places[nr][nc] = 2 # 청소 표시
    r, c = nr, nc # 다음 좌표값 설정
    cnt += 1 # 칸 count
    turn_cnt = 0 # 계속해서 count 되지 않게 초기화
    continue # 청소를 하였다면 뒷 부분의 조건을 확인할 필요가 없기 때문에 continue
  else: # 청소가 되어 있거나 벽이면
    turn_cnt += 1 # 회전 수 count

  if turn_cnt == 4: # 만약 네 방향 모두 청소가 이미 되어 있거나 벽인 경우
    # 후진을 한다는 것은 북이면 남으로, 동이면 서로 이동하는 것이므로 현재 방향에서 -2를 하면 후진할 방향이 나옴
    nr, nc = r + move[d % 4 - 2][0], c + move[d % 4 - 2][1] # 바라보는 방향 뒤쪽으로 후진
    r, c = nr, nc # 다음 좌표값 설정
    if places[nr][nc] == 1: # 만약 후진할 위치도 벽이라면 break
      break
    
    turn_cnt = 0 # 회전 수 초기화

print(cnt)
