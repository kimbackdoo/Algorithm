# 제일 마지막 레벨의 점수가 가장 높아야 하고, 나머지 레벨의 점수는 바로 다음 높은 레벨의 점수보다 1 낮으면 최소 횟수가 됨 따라서 그리디 알고리즘 적용
# 입력받은 각 레벨의 점수를 뒤집은 후 가장 마지막 레벨의 점수가 가장 높게 되도록 반복

n = int(input())

score = []
for _ in range(n):
  score.append(int(input()))

score.reverse() # 각 레벨의 점수를 뒤집음
result = 0
for i in range(len(score)-1):
  # 현재 레벨의 점수는 다음 레벨의 점수보다 1 높으면 되므로 현재 레벨의 점수와 다음 레벨의 점수를 비교
  if score[i] <= score[i+1]: # 만약 현재 레벨의 점수가 다음 레벨의 점수 보다 같거나 작다면
    # 레벨 감소 횟수 계산, 만약 현재 레벨 점수가 5, 다음 레벨의 점수가 7이라면 현재 레벨의 점수가 더 높기 위해서 다음 레벨의 점수가 4로 만들면 최소 횟수가 나옴
    # 따라서 5 - 1이 다음 레벨의 점수가 되어야 하고, 7 - 5 + 1이 최소 감소 횟수가 됨
    result += (score[i+1] - score[i] + 1)
    score[i+1] = score[i] - 1 # 다음 레벨의 점수 계산

print(result)
